<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_the_mechanics_of_execution_an_overview_of_code_generation">The Mechanics of Execution - An Overview of Code Generation</h2>
<div class="sectionbody">
<div class="paragraph"><p>This is an extended tutorial on how to generate backend code from
intermediate code.   Don&#8217;t start this until instructed. At
the very least, you should have intermediate code generation
working in your compiler first.</p></div>
<div class="paragraph"><p>With that out of the way, this document introduces
introduces the basic mechanics of writing an interpreter, a
transpiler, and generation of machine code using LLVM and WebAssembly.
In general, none of this is "hard" except that there often a lot of
fiddly bits concerning tooling and data formats.  Some simplifications
have been made to make encoding easier (at the expense of a bit of
space optimization).</p></div>
<div class="paragraph"><p>For this tutorial, we&#8217;re going to consider the following code fragment:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>var x int = 4;
var y int = 5;
var d int = x * x + y * y;
print d;</code></pre>
</div></div>
<div class="paragraph"><p>When compiled by your compiler, you should generate the following
intermediate code:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>code = [
   ('GLOBALI', 'x'),
   ('CONSTI', 4),
   ('STORE', 'x'),
   ('GLOBALI', 'y'),
   ('CONSTI', 5),
   ('STORE', 'y'),
   ('GLOBALI', 'd'),
   ('LOAD', 'x'),
   ('LOAD', 'x'),
   ('MULI',),
   ('LOAD', 'y'),
   ('LOAD', 'y'),
   ('MULI',),
   ('ADDI',),
   ('STORE', 'd'),
   ('LOAD', 'd'),
   ('PRINTI',)
]</code></pre>
</div></div>
<div class="paragraph"><p>Copy the above <code>code</code> variable to a Python file where you can use it
in some examples.</p></div>
<div class="sect2">
<h3 id="_part_a_writing_an_interpreter">Part (a) - Writing an Interpreter</h3>
<div class="paragraph"><p>One possible target for your compiler is to write an interpreter.  An
interpreter directly runs the instructions on a kind of simulated
machine. The simulated machine has memory, a stack, and a program
counter just like a real CPU.  Define the following class and try it
with the above code:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>class Interpreter:
    def __init__(self):
        self.store = { }
        self.stack = [ ]
        self.pc = 0

    def run(self, code):
        self.pc = 0
        while self.pc &lt; len(code):
            op, *opargs = code[self.pc]
            getattr(self, f'run_{op}')(*opargs)
            self.pc += 1

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        return self.stack.pop()

    def run_GLOBALI(self, name):
        self.store[name] = None

    def run_CONSTI(self, value):
        self.push(value)

    def run_STORE(self, name):
        self.store[name] = self.pop()

    def run_LOAD(self, name):
        self.push(self.store[name])

    def run_ADDI(self):
        self.push(self.pop() + self.pop())

    def run_MULI(self):
        self.push(self.pop() * self.pop())

    def run_PRINTI(self):
        print(self.pop())

# Run it!
interp = Interpreter()
interp.run(code)</code></pre>
</div></div>
<div class="paragraph"><p>Modify your interpreter by giving it a new instruction <code>SUBI</code> and
running it on this program which should produce an output of "1":</p></div>
<div class="listingblock">
<div class="content">
<pre><code>code = [
    ('CONSTI', 5),
    ('CONSTI', 4),
    ('SUBI',)
    ('PRINTI',)
]</code></pre>
</div></div>
<div class="paragraph"><p>Direct interpretation of simulated instructions on a simulated machine
is how various scripting languages such as Python, Ruby, PHP, and so
forth work.  This "simulation" is a big part of dynamic typing.  It&#8217;s
also why these languages run slower than compiled languages
like C.</p></div>
</div>
<div class="sect2">
<h3 id="_part_b_writing_a_transpiler">Part (b) - Writing a Transpiler</h3>
<div class="paragraph"><p>Instead of directly running intermediate code, another option is to
turn the code into source code for another programming language such
as Python or C.  This is how early versions of C++ worked. It&#8217;s also
the basis of modern languages such as TypeScript (transpiled to JavaScript).
A common target of transpiling is C.   Here is a transpiler that produces
Python:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>class Transpiler:
    def __init__(self):
        self.outcode = 'def main():\n'
        self.stack = [ ]

    def translate(self, code):
        for op, *opargs in code:
            getattr(self, f'translate_{op}')(*opargs)
        self.outcode += '\nmain()\n'
        return self.outcode

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        return self.stack.pop()

    def translate_GLOBALI(self, name):
        pass

    def translate_CONSTI(self, value):
        self.push(repr(value))

    def translate_STORE(self, name):
        self.outcode += f'    {name} = {self.pop()}\n'

    def translate_LOAD(self, name):
        self.push(name)

    def translate_ADDI(self):
        self.push(f'({self.pop()} + {self.pop()})')

    def translate_MULI(self):
        self.push(f'({self.pop()} * {self.pop()})')

    def translate_PRINTI(self):
        self.outcode += f'    print({self.pop()})\n'

trans = Transpiler()
print(trans.translate(code))</code></pre>
</div></div>
<div class="paragraph"><p>In this implementation, you still maintain an internal stack to manage
the construction of expressions (e.g., certain methods still push and pop
things from the stack).  However, instead of actually performing an
operation as with the interpreter, you&#8217;re now producing source code to
perform the operation.</p></div>
<div class="paragraph"><p>If you run the program, you should get this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 transpile.py
def main():
    x = 4
    y = 5
    d = ((y * y) + (x * x))
    print(d)

main()
bash %</code></pre>
</div></div>
<div class="paragraph"><p>Try redirecting the output to a file and running it:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 transpile.py &gt; out.py
bash % python3 out.py
41
bash %</code></pre>
</div></div>
<div class="paragraph"><p>See if you can modify the program so that it produces C instead, creating the following
output code:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>#include &lt;stdio.h&gt;
int main() {
    int x;
    int y;
    int d;
    x = 4;
    y = 5;
    d = ((y * y) + (x * x));
    printf("%i\n", (d));
}</code></pre>
</div></div>
<div class="paragraph"><p>If you&#8217;re making a new language, transpiling is often a easy approach for getting
things to work.  Take your language, transpile it to C, combine with a few
library functions and you&#8217;re running.</p></div>
</div>
<div class="sect2">
<h3 id="_part_c_generating_assembly_code_with_llvm">Part (c) - Generating Assembly Code with LLVM</h3>
<div class="paragraph"><p>With transpiling, you&#8217;re taking a high-level language and producing
output in a different high-level language.  Instead of that, you could
compile down to a low-level machine language that is either the actual
hardware or a very close approximation to it.  One such tool for doing
that is LLVM.  LLVM is used in a number of major projects such as the
clang C/C++ compiler.  It&#8217;s also used to implement various so-called
JIT (Just in Time) compilation features.</p></div>
<div class="paragraph"><p>LLVM is an extremely large project that can be daunting to jump into.
However, using it in a simple manner is not so bad. To explore the
basics, we&#8217;re going to use the <code>llvmlite</code> package.  This is available
in the Anaconda Python distribution so if you&#8217;re using that, you
should already have it.</p></div>
<div class="sect3">
<h4 id="_llvm_preliminaries">LLVM Preliminaries</h4>
<div class="paragraph"><p>Your first task is to make sure Anaconda Python and the clang C/C++
compiler have been installed on your machine. Please review the README
file for the compilers project regarding installation notes.</p></div>
</div>
<div class="sect3">
<h4 id="_hello_world">Hello World</h4>
<div class="paragraph"><p>The first step in using LLVM is to make a LLVM module which contains
all of the code you will be generating.  Create a file
<code>hellollvm.py</code> and put this code into it:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># hellollvm.py
from llvmlite.ir import Module

mod = Module('hello')
print(mod)</code></pre>
</div></div>
<div class="paragraph"><p>Run the program and you should get some output like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 hellollvm.py
; ModuleID = "hello"
target triple = "unknown-unknown-unknown"
target datalayout = ""

bash %</code></pre>
</div></div>
<div class="paragraph"><p>The output you&#8217;re seeing is LLVM low-level code&#8212;a kind of architecture
independent assembly language. At this point, it&#8217;s not too
interesting.  However, let&#8217;s declare a function to put in the module.
Change the program to the following to declare a function with the C
prototype <code>int hello()</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># hellollvm.py

from llvmlite.ir import (
    Module, Function, FunctionType, IntType
    )

mod = Module('hello')
int_type = IntType(32)
hello_func = Function(mod, FunctionType(int_type, []), name='hello')
print(mod)</code></pre>
</div></div>
<div class="paragraph"><p>Running the program, you should now get the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 hellollvm.py
; ModuleID = "hello"
target triple = "unknown-unknown-unknown"
target datalayout = ""

declare i32 @"hello"()

bash %</code></pre>
</div></div>
<div class="paragraph"><p>Again, it&#8217;s not too interesting yet.  However, you can see
how a function declaration was placed in the module output. The LLVM
statement <code>declare i32 @"hello"()</code> is declaring a function that
returns a 32-bit integer and takes no arguments.</p></div>
<div class="paragraph"><p>Let&#8217;s add some code to the function.  To do this, you first need to
create a basic block. A basic block is a container that holds
low-level instructions.  Add the following to the program:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># hellollvm.py

from llvmlite.ir import (
    Module, Function, FunctionType, IntType, IRBuilder
    )

mod = Module('hello')
int_type = IntType(32)
hello_func = Function(mod, FunctionType(int_type, []), name='hello')
block = hello_func.append_basic_block('entry')
builder = IRBuilder(block)
builder.ret(Constant(IntType(32), 37))
print(mod)</code></pre>
</div></div>
<div class="paragraph"><p>Running the program should now produce this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>; ModuleID = "hello"
target triple = "unknown-unknown-unknown"
target datalayout = ""

define i32 @"hello"()
{
entry:
  ret i32 37
}</code></pre>
</div></div>
<div class="paragraph"><p>There you are---a complete LLVM function that does nothing but return
the value 37. Now, a question arises: How do you go about getting it to run?</p></div>
</div>
<div class="sect3">
<h4 id="_compilation_to_a_standalone_executable">Compilation to a Standalone Executable</h4>
<div class="paragraph"><p>If you want to run your LLVM generated code, one approach is to feed it
to a LLVM-based compiler such as <code>clang</code>.  Save your generated
code to a file <code>hello.ll</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 hellollvm.py &gt; hello.ll
bash %</code></pre>
</div></div>
<div class="paragraph"><p>Now, write a short C program to bootstrap the function:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>/* main.c */
#include &lt;stdio.h&gt;

extern int hello();

int main() {
    printf("hello() returned %i\n", hello());
}</code></pre>
</div></div>
<div class="paragraph"><p>Compile this program together with <code>hello.ll</code> to make an executable:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % clang main.c hello.ll
bash % ./a.out
hello() returned 37
bash %</code></pre>
</div></div>
<div class="paragraph"><p>This basic technique for invoking your code and creating stand-alone
programs will be useful for testing and development.  You also get the
advantage of being able to use C library functions such as
<code>printf()</code>.  Without this, you&#8217;d have to figure out how to perform
I/O directly using low-level LLVM instructions&#8212;which would not be
fun.</p></div>
</div>
<div class="sect3">
<h4 id="_just_in_time_compilation">Just in Time Compilation</h4>
<div class="paragraph"><p>In our example, we are creating LLVM instructions, writing them to a
file, and using the <code>clang</code> compiler to produce an executable.
It&#8217;s possible that this won&#8217;t work due to the local setup on
your machine (maybe you don&#8217;t have clang installed correctly).
One feature of LLVM is that it can compile it&#8217;s own code to executable
machine instructions without ever going to a file or using clang.
You can do this entirely in Python and have Python call the resulting
function.</p></div>
<div class="paragraph"><p>This part is rather tricky and obscure, but add the following code to
<code>hellollvm.py</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># hellollvm.py

... keep earlier LLVM example here ...

def run_jit(module):
    import llvmlite.binding as llvm

    llvm.initialize()
    llvm.initialize_native_target()
    llvm.initialize_native_asmprinter()

    target = llvm.Target.from_default_triple()
    target_machine = target.create_target_machine()
    compiled_mod = llvm.parse_assembly(str(module))
    engine = llvm.create_mcjit_compiler(compiled_mod, target_machine)

    # Look up the function pointer (a Python int)
    func_ptr = engine.get_function_address("hello")

    # Turn into a Python callable using ctypes
    from ctypes import CFUNCTYPE, c_int
    hello = CFUNCTYPE(c_int)(func_ptr)

    res = hello()
    print('hello() returned', res)

# Run it!
run_jit(mod)</code></pre>
</div></div>
<div class="paragraph"><p>If you run this, you should see the program run the code, and
produce output such as this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 hellollvm.py
hello() returned 37
bash %</code></pre>
</div></div>
<div class="paragraph"><p>This version runs entirely inside an active Python interpreter process.
If you can&#8217;t get clang to work, you can always use this as a fallback.</p></div>
</div>
<div class="sect3">
<h4 id="_local_variables_and_math_operations">Local Variables and Math Operations</h4>
<div class="paragraph"><p>To do more with LLVM, you need to use more instructions on the
<code>builder</code> object in the example.   To declare a local variable "x",
you use this method:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>x = builder.alloca(int_type, name="x")</code></pre>
</div></div>
<div class="paragraph"><p>To load and store values, you use these instructions:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>r = builder.load(x)        # Load a value from x into r
builder.store(r, x)        # Store r into y</code></pre>
</div></div>
<div class="paragraph"><p>To perform arithmetic, you use instructions such as these:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>r3 = builder.add(r1, r2)   # r3 = r1 + r2
r3 = builder.mul(r1, r2)   # r3 = r1 + r2</code></pre>
</div></div>
<div class="paragraph"><p>Here is an example that implements the program given at the start
of this exercise:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># hellollvm.py
from llvmlite.ir import (
    Module, Function, FunctionType, IntType,
    Constant, IRBuilder
    )

mod = Module('hello')
int_type = IntType(32)

hello_func = Function(mod, FunctionType(int_type, []), name='hello')
block = hello_func.append_basic_block('entry')
builder = IRBuilder(block)

x = builder.alloca(int_type, name='x')
y = builder.alloca(int_type, name='y')
builder.store(Constant(int_type, 4), x)
builder.store(Constant(int_type, 5), y)
r1 = builder.load(x)
r2 = builder.mul(r1, r1)
r3 = builder.load(y)
r4 = builder.mul(r3, r3)
r5 = builder.add(r2, r4)
d = builder.alloca(int_type, name='d')
builder.store(r5, d)
builder.ret(builder.load(d))

print(mod)</code></pre>
</div></div>
<div class="paragraph"><p>An important thing about LLVM is that it is NOT a stack machine. It is based
on registers and Single Static Assignment (SSA).  Basically, every operation
produces a new variable that can only be assigned once.  It also requires explicit
load/store instructions to go between local variables and registers.  In the
above example, you can&#8217;t do an instruction such as <code>builder.add(x, y)</code> between
local variables.  You have to load the variables into registers first and
perform the instruction on the registers.</p></div>
<div class="paragraph"><p>Try compiling the above program and running you code again:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 hellollvm.py &gt; hello.ll
bash % clang main.c hello.ll
bash % ./a.out
hello() returned 41
bash %</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_functions_with_arguments">Functions with Arguments</h4>
<div class="paragraph"><p>Let&#8217;s make a more interesting function.  This function takes two
arguments <code>x</code> and <code>y</code> and computes the value <code>x**2 + y**2</code>.  To
do this, we&#8217;re going to follow similar steps as above. First, declare
the function, add a basic block, and make a new builder.  Once the
builder is obtained, we&#8217;ll create some instructions to compute and
return the result. Add the following code to your <code>hellollvm.py</code>
program:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># hellollvm.py
...

# A user-defined function
from llvmlite.ir import DoubleType

ty_double = DoubleType()
dsquared_func = Function(mod,
                         FunctionType(ty_double, [ty_double, ty_double]),
                         name='dsquared')
block = dsquared_func.append_basic_block('entry')
builder = IRBuilder(block)

# Get the function args
x, y = dsquared_func.args

# Compute temporary values for x*x and y*y
xsquared = builder.fmul(x, x)
ysquared = builder.fmul(y, y)

# Sum the values and return the result
d2 = builder.fadd(xsquared, ysquared)
builder.ret(d2)

# Output the final module
print(mod)</code></pre>
</div></div>
<div class="paragraph"><p>One thing to notice is that you use the builder to carry out the steps
needed to perform the calculation that you&#8217;re trying to perform. Python
variables such as <code>x</code>, <code>xsquared</code>, and <code>d2</code> are being used to
hold intermediate results.</p></div>
<div class="paragraph"><p>If you run this program, you should output similar to the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>; ModuleID = "hello"
...

define double @"dsquared"(double %".1", double %".2")
{
entry:
  %".4" = fmul double %".1", %".1"
  %".5" = fmul double %".2", %".2"
  %".6" = fadd double %".4", %".5"
  ret double %".6"
}</code></pre>
</div></div>
<div class="paragraph"><p>To test it, modify the C bootstrap code as follows:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>/* main.c */
#include &lt;stdio.h&gt;

extern int hello();
extern double dsquared(double, double);

int main() {
  printf("Hello returned: %i\n", hello());
  printf("dsquared(3, 4) = %f\n", dsquared(3.0, 4.0));
}</code></pre>
</div></div>
<div class="paragraph"><p>Compile as follows:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 hellollvm.py &gt; hello.ll
bash % clang main.c hello.ll
bash % ./a.out
Hello returned: 41
dsquared(3, 4) = 25.000000
bash %</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_calling_an_external_function">Calling an external function</h4>
<div class="paragraph"><p>Even though you&#8217;re emitting low-level assembly code, there&#8217;s no need
to completely reinvent the wheel from scratch.  One problem concerns
printing.  In our IR code, there is an instruction to print a value
to the screen.  How do you do that in LLVM?  The short answer is that
you don&#8217;t (well, unless you&#8217;re some kind of masochist).  You do printing
in C.  Make a new file <code>runtime.c</code> and put a
a <code>_print_int()</code> function in it like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>/* runtime.c */
#include &lt;stdio.h&gt;

void _print_int(int x) {
    printf("out: %i\n", x);
}</code></pre>
</div></div>
<div class="paragraph"><p>Now, suppose you wanted to call that function from LLVM.  To do it,
you need to declare it:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># hellollvm.py
...
from llvmlite.ir import VoidType, IntType

void_type = VoidType()
int_type = IntType(32)

_print_int = Function(mod,
                     FunctionType(void_type, [int_type]),
                     name='_print_int')</code></pre>
</div></div>
<div class="paragraph"><p>To call the function, you use the <code>builder.call()</code> instruction:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>r2 = builder.call(_print_int, [r1])</code></pre>
</div></div>
<div class="paragraph"><p>Change your <code>hellollvm.py</code> program so that it looks like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># hellollvm.py

from llvmlite.ir import (
    Module, Function, FunctionType, IntType, VoidType,
    Constant, IRBuilder
    )

mod = Module('hello')

int_type = IntType(32)
void_type = VoidType()

_print_int = Function(mod,
                      FunctionType(void_type, [int_type]),
                      name='_print_int')

hello_func = Function(mod, FunctionType(int_type, []), name='hello')
block = hello_func.append_basic_block('entry')
builder = IRBuilder(block)

x = builder.alloca(int_type, name='x')
y = builder.alloca(int_type, name='y')
builder.store(Constant(int_type, 4), x)
builder.store(Constant(int_type, 5), y)
t1 = builder.load(x)
t2 = builder.load(x)
t3 = builder.mul(t1, t2)
t4 = builder.load(y)
t5 = builder.load(y)
t6 = builder.mul(t4, t5)
t7 = builder.add(t3, t6)
d = builder.alloca(int_type, name='d')
builder.store(t7, d)
builder.call(_print_int, [builder.load(d)])     # Call _print_int()
builder.ret(Constant(int_type, 37))             # Return 37
print(mod)</code></pre>
</div></div>
<div class="paragraph"><p>Compile and run (note inclusion of <code>runtime.c</code>):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 hellollvm.py &gt; hello.ll
bash % clang main.c runtime.c hello.ll
bash % ./a.out
out: 41
hello() returned 41
bash %</code></pre>
</div></div>
<div class="paragraph"><p>Notice that there is output from the <code>_print_int()</code> function as well as
the return value from the <code>hello()</code> function itself.</p></div>
<div class="paragraph"><p>As an aside, you can implement almost anything that you want in C and
link it as library code into your output assembly code.  Printing,
memory access, and all sorts of other things could potentially be
written in this way.  You&#8217;ll have to do some of this in the project.</p></div>
</div>
<div class="sect3">
<h4 id="_global_variables_and_state">Global Variables and State</h4>
<div class="paragraph"><p>You might want to define a variable that keeps its state.  Let&#8217;s make
a global variable <code>x</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># hellollvm.py
...
from llvmlite.ir import GlobalVariable
x_var = GlobalVariable(mod, ty_double, 'x')
x_var.initializer = Constant(ty_double, 0.0)</code></pre>
</div></div>
<div class="paragraph"><p>Now, let&#8217;s write a function that increments the variable and
prints its new value.  To do this, you use <code>load</code> and <code>store</code>
instructions to manipulate the variable state:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># hellollvm.py
...

from llvmlite.ir import VoidType

incr_func = Function(mod,
                     FunctionType(VoidType(), []),
                     name='incr')
block = incr_func.append_basic_block('entry')
builder = IRBuilder(block)
tmp1 = builder.load(x_var)
tmp2 = builder.fadd(tmp1, Constant(ty_double, 1.0))
builder.store(tmp2, x_var)
builder.ret_void()</code></pre>
</div></div>
<div class="paragraph"><p>Modify the <code>main.c</code> file as follows:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>/* main.c */
#include &lt;stdio.h&gt;

extern int hello();
extern double dsquared(double, double);
extern double x;
extern void incr();

int main() {
  printf("Hello returned: %i\n", hello());
  printf("dsquared(3, 4) = %f\n", dsquared(3.0, 4.0));
  printf("x is %f\n", x);
  incr();
  printf("x is now %f\n", x);
}</code></pre>
</div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Compile and run the program again
</dt>
<dd>
</dd>
</dl></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 hellollvm.py &gt; hello.ll
bash % clang main.c hello.ll -lm
bash % ./a.out
out: 41
Hello returned: 41
dsquared(3, 4) = 25.000000
x is 0.000000
x is now 1.000000
bash %</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_compiling_to_llvm">Compiling to LLVM</h4>
<div class="paragraph"><p>In building your compiler, you&#8217;ll need to figure out how to translate
IR code into the appropriate low-level LLVM operations.  This part
is left to the project, but the mechanics of it are going to be almost
identical to the interpreter/transpiler exercises you did earlier.
You need to keep track of variables. You need a stack to keep track of
LLVM values. Most of the code generation will involve operations on this
stack.</p></div>
</div>
<div class="sect3">
<h4 id="_a_llvm_mini_reference">A LLVM Mini-Reference</h4>
<div class="paragraph"><p>This section aims to provide a mini-reference for using LLVM in the
next part of the project.   It summarizes some of the critical bits.</p></div>
<div class="paragraph"><p>For creating LLVM code, use the following import:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>from llvmlite.ir import (
     Module, Function, FunctionType, IRBuilder,
     IntType, DoubleType, VoidType, Constant
)</code></pre>
</div></div>
<div class="paragraph"><p>All LLVM code is placed in a module.  You create one like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>mod = Module("modname")</code></pre>
</div></div>
<div class="paragraph"><p>You declare functions like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>func = Function(mod,
                FunctionType(rettype, [argtypes]),
                name="funcname")</code></pre>
</div></div>
<div class="paragraph"><p>The following basic datatypes are used heavily in declarations:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>IntType(32)             # A 32-bit integer
DoubleType()            # A double-precision float</code></pre>
</div></div>
<div class="paragraph"><p>It is usually easier to make aliases for the types:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>int_type = IntType(32)
float_type = DoubleType()</code></pre>
</div></div>
<div class="paragraph"><p>To define constants corresponding to the above types, do this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>c = Constant(int_type, value)
d = Constant(float_type, value)</code></pre>
</div></div>
<div class="paragraph"><p>To start adding code to a function, you must add a basic block
and create a builder.  For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>block = func.append_basic_block('entry')
builder = IRBuilder(block)</code></pre>
</div></div>
<div class="paragraph"><p>Builder objects have a variety of useful methods for adding
instructions.  These include:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># Returning values
builder.ret(value)
builder.ret_void()

# Integer math
result = builder.add(left, right)
result = builder.sub(left, right)
result = builder.mul(left, right)
result = builder.sdiv(left, right)

# Floating math
result = builder.fadd(left, right)
result = builder.fsub(left, right)
result = builder.fmul(left, right)
result = builder.fdiv(left, right)

# Function call
result = builder.call(func, args)</code></pre>
</div></div>
<div class="paragraph"><p>When using the builder, it is important to emphasize that you must
save the results of the above operations and use them in subsequent
calls.  For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>t1 = builder.fmul(a, b)
t2 = builder.fmul(c, d)
t3 = builder.fadd(t1, t2)
...</code></pre>
</div></div>
<div class="paragraph"><p>To declare a local variable do something like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>name_var = builder.alloca(int_type, name='varname')</code></pre>
</div></div>
<div class="paragraph"><p>To declare a global variabel do something like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>x_var = GlobalVariable(mod, ty_double, 'x')
x_var.initializer = Constant(ty_double, 0.0)</code></pre>
</div></div>
<div class="paragraph"><p>To access either kind of variable, use load and store instructions:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>tmp = builder.load(name_var)
builder.store(tmp, name_var)</code></pre>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="_part_d_taking_it_to_the_web_assembly">Part (d) - Taking it to the Web (Assembly)</h3>
<div class="paragraph"><p>As our final target, we&#8217;re going to compile our code to Web Assembly
(Wasm).  Wasm is a relatively new technology that is usually
introduced with a fairly complicated toolchain.  For example, it is
possible to compile C, C++, Rust, and other languages to Wasm and to
have that code run (somehow) in the browser.  You can even find demos
of game engines and other interesting things.  However, it can be a
bit tough to wrap your brain around what&#8217;s happening.  In this last
part, we&#8217;re going to look at raw low-level Wasm without any assistive
tooling.  This is not the way that you&#8217;d likely work with it for real,
but for the purposes of a compilers course, it&#8217;s instructive.</p></div>
<div class="paragraph"><p>At a high-level, Wasm is a small "machine code" that is not too unlike
the IR Code for our compiler.  It simulates a stack machine and it
only understands 4 datatypes&#8212;integers and floats in both 32-bit and
64-bit encodings.  The main difference is that Wasm is encoded in a
compact binary encoding---not a list of tuples as we have done.
Much of our effort to make Wasm work concerns details of the binary
encoding.</p></div>
<div class="paragraph"><p>As a note: To make it somewhat simpler to describe, our encoding will not be
as compact as it could be.  Web Assembly uses a number of techniques
to compress the size of the output file at the expense of added encoding
complexity.  For the purpose of a course, it&#8217;s probably better to optimize
for simplicity instead.</p></div>
<div class="sect3">
<h4 id="_low_level_encoding_of_values">Low-level Encoding of Values</h4>
<div class="paragraph"><p>To start out, there are some basic encodings of integers, floats, and
text strings that need to take place.</p></div>
<div class="paragraph"><p>Integers are encoded into a LEB-128, a variable length encoding. The
following functions can be used for this purpose:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>def encode_unsigned(value):
    '''
    Produce an LEB128 encoded unsigned integer.
    '''
    parts = []
    while value:
        parts.append((value &amp; 0x7f) | 0x80)
        value &gt;&gt;= 7
    if not parts:
        parts.append(0)
    parts[-1] &amp;= 0x7f
    return bytes(parts)

def encode_signed(value):
    '''
    Produce a LEB128 encoded signed integer.
    '''
    parts = [ ]
    if value &lt; 0:
        # Sign extend the value up to a multiple of 7 bits
        value = (1 &lt;&lt; (value.bit_length() + (7 - value.bit_length() % 7))) + value
        negative = True
    else:
        negative = False
    while value:
        parts.append((value &amp; 0x7f) | 0x80)
        value &gt;&gt;= 7
    if not parts or (not negative and parts[-1] &amp; 0x40):
        parts.append(0)
    parts[-1] &amp;= 0x7f
    return bytes(parts)

assert encode_unsigned(624485) == bytes([0xe5, 0x8e, 0x26])
assert encode_unsigned(127) == bytes([0x7f])
assert encode_signed(-624485) == bytes([0x9b, 0xf1, 0x59])
assert encode_signed(127) == bytes([0xff, 0x00])</code></pre>
</div></div>
<div class="paragraph"><p>Floating point numbers are encoded directly as a little-endian 8-byte double precision
value using this function:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>def encode_f64(value):
    '''
    Encode a 64-bit float point as little endian
    '''
    return struct.pack('&lt;d', value)</code></pre>
</div></div>
<div class="paragraph"><p>Wasm sometimes involves the encoding of a so-called "vector".  A vector is
list of identically typed items. For example, you could have a vector of
integers, a vector of floats, a vector of bytes, and so forth.  Vectors are
encoded as an unsigned length followed by the raw encoding of whatever items
it contains.  So, write the following function:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>def encode_vector(items):
    '''
    A size-prefixed collection of objects.  If items is already
    bytes, it is prepended by a length and returned.  If items
    is a list of byte-strings, the length of the list is prepended
    to byte-string formed by concatenating all of the items.
    '''
    if isinstance(items, bytes):
        return encode_unsigned(len(items)) + items
    else:
        return encode_unsigned(len(items)) + b''.join(items)</code></pre>
</div></div>
<div class="paragraph"><p>Names are represented as a UTF-8 encoded vector of bytes.  The following
function will encoded a name:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>def encode_name(name):
    '''
    Encode a text name as a UTF-8 vector
    '''
    return encode_vector(name.encode('utf-8'))</code></pre>
</div></div>
<div class="paragraph"><p>The first rule of Wasm is that ALL literal values (integers, floats, names, etc.) must
be encoded by these functions. So, put these in a file <code>wasm.py</code> and use it as a starting
point.</p></div>
<div class="paragraph"><p>Try a few examples to see what the encodings look like:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&gt;&gt;&gt; encode_unsigned(1234)
b'\xd2\t'
&gt;&gt;&gt; encode_signed(-1234)
b'\xaev'
&gt;&gt;&gt; encode_f64(123.45)
b'\xcd\xcc\xcc\xcc\xcc\xdc^@'
&gt;&gt;&gt; encode_name('spam')
b'\x04spam'
&gt;&gt;&gt;</code></pre>
</div></div>
<div class="paragraph"><p>Reminder: You must use these functions.</p></div>
</div>
<div class="sect3">
<h4 id="_some_basic_instructions">Some Basic Instructions</h4>
<div class="paragraph"><p>Wasm defines a set of instructions similar to our own IR code.  Wasm
is also a stack machine just like our IR code. The following table
shows a few basic instruction encodings:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>b'\x41' &lt;val&gt;  =&gt; i32.const (val is signed integer)
b'\x6a'        =&gt; i32.add
b'\x6b'        =&gt; i32.sub
b'\x6c'        =&gt; i32.mul
b'\x6d'        =&gt; i32.div_s
b'\x0b'        =&gt; end block</code></pre>
</div></div>
<div class="paragraph"><p>Using this, we can start to write a basic Wasm instruction encoder for our example
code. This is surprising easy---since Wasm is also a stack machine, we
don&#8217;t need to maintain a stack or do much of anything other than translate
the tuples of IR code into the binary coded version in Wasm:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>class WasmEncoder:
    def encode(self, code):
        self.wcode = b''
        for op, *opargs in code:
            getattr(self, f'encode_{op}')(*opargs)

        # Put a block terminator on the code
        self.wcode += b'\x0b'

    def encode_CONSTI(self, value):
        self.wcode += b'\x41' + encode_signed(value)

    def encode_ADDI(self):
        self.wcode += b'\x6a'

    def encode_MULI(self):
        self.wcode += b'\x6c'

    def encode_PRINTI(self):
        # TO-DO
        pass

    def encode_GLOBALI(self, name):
        # TO-DO
        pass

    def encode_STORE(self, name):
        # TO-DO
        pass

    def encode_LOAD(self, name):
        # TO-DO
        pass


encoder = WasmEncoder()
encoder.encode(code)
print(encoder.wcode)</code></pre>
</div></div>
<div class="paragraph"><p>Try running this example. You should get some low-level output that looks like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 wasm.py
b'A\x04A\x05llj\x0b'
bash %</code></pre>
</div></div>
<div class="paragraph"><p>The output is binary and not meant to be easily human readable.</p></div>
</div>
<div class="sect3">
<h4 id="_types_and_global_variables">Types and Global Variables</h4>
<div class="paragraph"><p>The low-level instruction stream you just generated is incomplete. Instructions
related to global variables were left unimplemented.  To do this, a bit
more information is needed.</p></div>
<div class="paragraph"><p>Wasm only has a four datatypes. Instead of being referenced by nice names
like "int" or "float", they are identified by specific byte values:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>i32 = b'\x7f'   # (32-bit int)
i64 = b'\x7e'   # (64-bit int)
f32 = b'\x7d'   # (32-bit float)
f64 = b'\x7c'   # (64-bit float)</code></pre>
</div></div>
<div class="paragraph"><p>Put the above definitions in your encoder.  Instead of using a raw byte
value like <code>b'\x7f'</code>, you&#8217;ll use the name <code>i32</code>.</p></div>
<div class="paragraph"><p>A global variable in Wasm consists of a type, a mutability flag, and a
constant initial value.  All of the variables are stored in a table
which you can represent as a Python list.  Here is an example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>global_defns = [
    i32 + b'\x01\x41' + encode_signed(initial) + b'\x0b',  # integer
    f64 + b'\x01\x44' + encode_f64(initial) + b'\x0b',     # float
    ...
]</code></pre>
</div></div>
<div class="paragraph"><p>To load/store global variables, a pair of instructions are used:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>b'\x23' &lt;globidx&gt;  =&gt; global.get
b'\x24' &lt;globidx&gt;  =&gt; global.set</code></pre>
</div></div>
<div class="paragraph"><p>The <code>global.get</code> instruction loads a variable from a global and puts it on
the stack.  The <code>global.set</code> instruction stores the top of the stack into
a variable.  The <code>globidx</code> value is an unsigned integer index into the
globals table.   To associate this with a variable name, you&#8217;ll need to
maintain a separate dictionary:</p></div>
<div class="listingblock">
<div class="content">
<pre><code># Mapping of variable names to global variable table indices
globals = {
   'x':   0,
   'y':   1,
   ...
}</code></pre>
</div></div>
<div class="paragraph"><p>Putting all of this together, here is how global variables get
added to your encoder:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>class WasmEncoder:
    def __init__(self):
        # Global variable table
        self.global_defns = [ ]

        # Table mapping global names to definition index
        self.globals = { }
    ...

    def encode_GLOBALI(self, name):
        self.globals[name] = len(self.global_defns)
        self.global_defns.append(i32 + b'\x01\x41' + encode_signed(0) + b'\x0b')

    def encode_STORE(self, name):
        self.wcode += b'\x24' + encode_unsigned(self.globals[name])

    def encode_LOAD(self, name):
        self.wcode += b'\x23' + encode_unsigned(self.globals[name])</code></pre>
</div></div>
<div class="paragraph"><p>Add these to your encoder and look at the resulting output.  It
should look something like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 wasm.py
b'A\x04$\x00A\x05$\x01#\x00#\x00l#\x01#\x01lj$\x02#\x02\x0b'
bash %</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_function_encoding">Function Encoding</h4>
<div class="paragraph"><p>The low-level instruction stream you just generated is not enough to
make Wasm work.  Wasm requires all code to be packaged up inside a
proper function.  To do this, you need to deconstruct function definitions
into parts. Consider the following Wabbit function:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>func spam(x int, y int) int {
    var z int;
    z = x + y;
    return z;
}</code></pre>
</div></div>
<div class="paragraph"><p>The function consists of three different parts.  There is a textual
name <code>'spam'</code>, a type signature <code>(int, int)-&gt;int</code>, and a function
body that contains the function code.   In Wasm, these three components
are stored in separate tables.</p></div>
<div class="paragraph"><p>In Wasm, a function type signature is expressed as a pair of tuples
containing the parameter and return types. For example, the signature
for <code>spam()</code> above is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>[(i32, i32), (i32,)]</code></pre>
</div></div>
<div class="paragraph"><p>or if you fill in the raw type-codes:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>[(b'\x7f', b'\x7f'), (b'\x7f',)]</code></pre>
</div></div>
<div class="paragraph"><p>To encode a signature into bytes, use the following function:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>def encode_signature(argtypes, rettypes):
    return b'\x60' + encode_vector(argtypes) + encode_vector(rettypes)</code></pre>
</div></div>
<div class="paragraph"><p>Type signatures for all functions are stored in a list.  For example,
suppose you had the following functions in your Wasm file:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>func spam(x int, y int) int;
func square(x float) float;
func blah(x float, y int) float;</code></pre>
</div></div>
<div class="paragraph"><p>You will make a type-signature list like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>signatures = [
   encode_signature([i32, i32], [i32]),    # spam
   encode_signature([f64], [f64]),         # square
   encode_signature([f64, i32], [f64]),    # blah
]</code></pre>
</div></div>
<div class="paragraph"><p>Carefully notice that the signature table contains no information
about function names.  For that, you need to maintain a separate
dictionary that maps names to an associated type index.  For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>functions = {
   'spam': 0,       # Index refers to type signature table
   'square': 1,
   'blah': 2,
}</code></pre>
</div></div>
<div class="paragraph"><p>The code associated with each function is also stored in a table.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>funccode = [
    b'...',        # Code for spam
    b'...',        # Code for square
    b'...',        # Code for blah
]</code></pre>
</div></div>
<div class="paragraph"><p>The code stored here is the same code that you&#8217;ve been making so far.
However, some additional considerations must be made to handle local
variables. Consider the following function again:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>func spam(x int, y int) int {
    var z int;
    z = x + y;
    return z;
}</code></pre>
</div></div>
<div class="paragraph"><p>This function has two parameters (<code>x</code>, <code>y</code>) and a local variable <code>z</code>.
These variables are numbered starting at 0 (parameters go first).  You
need to make a dict that maps variable names to numerical indices:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>locals = {
    'x': 0,
    'y': 1,
    'z': 2,
}</code></pre>
</div></div>
<div class="paragraph"><p>The following Wasm instructions are used to load/store local variables:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>b'\x20' &lt;localidx&gt;  =&gt; local.get
b'\x21' &lt;localidx&gt;  =&gt; local.set</code></pre>
</div></div>
<div class="paragraph"><p>Here, <code>localidx</code> is an unsigned integer index that refers to the
variable (the same index that&#8217;s stored in the <code>locals</code> variable above).</p></div>
<div class="paragraph"><p>The types of the function parameters are stored as part of the
signature.  However, the types of additional local variables (declared
inside the function) must be stored in a separate list.  So, you need
to keep a separate record like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>localtypes = [ b'\x01' + i32 ]     # Type of z</code></pre>
</div></div>
<div class="paragraph"><p>It looks a little funny, but each local variable type is encoded with
<code>b'\x01'+&lt;typecode&gt;</code>.    The contents of this list are encoded as a
vector and prepended to the raw instruction code that you already
created.    The entire function body (locals + code) is then prepended
by an integer length giving its size in bytes.  Structurally, it&#8217;s going
to look like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>[ length | locals | instructions ]</code></pre>
</div></div>
<div class="paragraph"><p>Last, but not least, you need to export your newly created function
so that it can be accessed.  To do that, you make an exports list like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>exports = []

# An a function "name" to the exports list
exports.append(encode_name(name) + b'\x00' + encode_unsigned(functions[name]))</code></pre>
</div></div>
<div class="paragraph"><p>This is a lot to unpack, but here is a modified encoder that includes
the necessary function support:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>def encode_signature(argtypes, rettypes):
    return b'\x60' + encode_vector(argtypes) + encode_vector(rettypes)

class WasmEncoder:
    def __init__(self):
        # Global variables
        self.global_defns = [ ]

        # Global variable symbol table mapping names to declarations
        self.globals = { }

        # Function type signatures
        self.signatures = [ ]

        # Function name -&gt; signature map
        self.functions = { }

        # Function bodies
        self.funccode = [ ]

        # Exported functions
        self.exports = [ ]

    def encode_function(self, name, parmnames, parmtypes, rettypes, code):
        self.functions[name] = len(self.signatures)
        self.signatures.append(encode_signature(parmtypes, rettypes))
        self.exports.append(encode_name(name) + b'\x00' + encode_unsigned(self.functions[name]))

        # Create the local variable mapping
        self.locals = { pname: n for n, pname in enumerate(parmnames) }
        self.localtypes = [ ]

        # Emit instructions
        self.wcode = b''
        for op, *opargs in code:
            getattr(self, f'encode_{op}')(*opargs)

        # Put a block terminator on the code
        self.wcode += b'\x0b'

        # Save the function code body
        code = encode_vector(self.localtypes) + self.wcode
        self.funccode.append(encode_unsigned(len(code)) + code)

    ... rest unchanged ...

# Example use
encoder = WasmEncoder()
encoder.encode_function("main", [], [], [i32], code)</code></pre>
</div></div>
<div class="paragraph"><p>If you run this code and inspect various attributes of the encoder, you
should see the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&gt;&gt;&gt; encoder.signatures
[b'`\x00\x01\x7f']
&gt;&gt;&gt; encoder.functions
{'main': 0}
&gt;&gt;&gt; encoder.funccode
[b'\x19\x00A\x04$\x00A\x05$\x01#\x00#\x00l#\x01#\x01lj$\x02#\x02\x0b']
&gt;&gt;&gt; encoder.exports
[b'\x04main\x00\x00']
&gt;&gt;&gt;</code></pre>
</div></div>
<div class="paragraph"><p>We&#8217;re almost at a point where you can make something run.  The last step is to
make a proper Wasm module.</p></div>
</div>
<div class="sect3">
<h4 id="_encoding_a_module">Encoding a Module</h4>
<div class="paragraph"><p>Your final step in encoding Wasm is to make an encoded module. A module
is broken up into sections and looks like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>                +----------------------------+
 Header    :    | b'\x00asm\x01\x00\x00\x00' |
                +----------------------------+
 Section 1 :    |    type signatures         |
                +----------------------------+
 Section 3 :    |    function types          |
                +----------------------------+
 Section 6 :    |    globals                 |
                +----------------------------+
 Section 7 :    |    exports                 |
                +----------------------------+
 Section 10 :   |    function code           |
                +----------------------------+</code></pre>
</div></div>
<div class="paragraph"><p>There are other optional sections that are not needed right now.  The encoding
of each section is a 1-byte section number, a section length, and section contents.
Write the following functions:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>def encode_section(sectnum, contents):
    return bytes([sectnum]) + encode_unsigned(len(contents)) + contents</code></pre>
</div></div>
<div class="paragraph"><p>The contents of each section is encoded as a vector. So, to encode
section 1 for instance, you would do this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>encode_section(1, encode_vector(signatures))</code></pre>
</div></div>
<div class="paragraph"><p>Put all of this together by adding an <code>encode_module()</code> method like
this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>class WasmEncoder:
    ...
    def encode_module(self):
        module = b'\x00asm\x01\x00\x00\x00'
        module += encode_section(1, encode_vector(self.signatures))
        vec = [encode_unsigned(v) for v in self.functions.values()]
        module += encode_section(3, encode_vector(vec))
        module += encode_section(6, encode_vector(self.global_defns))
        module += encode_section(7, encode_vector(self.exports))
        module += encode_section(10, encode_vector(self.funccode))
        return module

# Example use:
encoder = WasmEncoder()
encoder.encode_function("main", [], [], [i32], code)
with open('out.wasm', 'wb') as file:
    file.write(encoder.encode_module())</code></pre>
</div></div>
<div class="paragraph"><p>Put this in your file and run it.  You should get a file <code>out.wasm</code>
written in the current directory.</p></div>
</div>
<div class="sect3">
<h4 id="_loading_it_in_the_browser">Loading it in the Browser</h4>
<div class="paragraph"><p>Wasm doesn&#8217;t run by itself.  It needs to be launched from Javascript.
Create a file <code>hello.html</code> that contains the following HTML and
Javascript:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;h3&gt;Program Output&lt;/h3&gt;

&lt;pre id="myout"&gt;The output is: &lt;/pre&gt;

&lt;script&gt;
    var imports = { };
    fetch("out.wasm").then(response =&gt;
       response.arrayBuffer()
    ).then(bytes =&gt;
       WebAssembly.instantiate(bytes, imports)
    ).then(results =&gt; {
       window.main = results.instance.exports.main;
       out = window.main();
       document.getElementById("myout").innerHTML += out + "\n";
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div></div>
<div class="paragraph"><p>In this code, the <code>out.wasm</code> file is fetched and instantiated into a WebAssembly
instance.  The <code>main()</code> function is lifted out of the instance exports
section. When called, its output is appended to the HTML in the <code>&lt;pre&gt;</code>
section at the top.</p></div>
<div class="paragraph"><p>To test this, go to the command line and the same directory as the <code>hello.html</code>
and <code>out.wasm</code> file.  Run the following Python command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>bash % python3 -m http.server</code></pre>
</div></div>
<div class="paragraph"><p>This launches a web server.  Now click on
<a href="http://localhost:8000/hello.html">http://localhost:8000/hello.html</a>.  You should see an output of "41".
If you see nothing, open the JavaScript dev console in your browser,
reload, and look for error messages.  Even the slightest error in
encoding your module will cause it to fail. Ask for help if stuck.</p></div>
</div>
<div class="sect3">
<h4 id="_building_the_runtime">Building the Runtime</h4>
<div class="paragraph"><p>Wasm is extremely low-level and minimal.  Keep in mind you only get integers and floats.
There are no strings. Or even any built-in functions!  Wasm doesn&#8217;t get access to
any part of Javascript or the browser environment all by itself.  This
presents certain logistical problems.  For example, how do you implement the
<code>PRINTI</code> instruction?</p></div>
<div class="paragraph"><p>The solution here is the same as the solution in LLVM!  If you want printing,
you implement it in JavaScript, not Wasm.   Go to the <code>hello.html</code> file and
modify the code so it looks like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;h3&gt;Program Output&lt;/h3&gt;

&lt;pre id="myout"&gt;The output is: &lt;/pre&gt;

&lt;script&gt;
    var imports = {
       runtime : {
           _printi: (x) =&gt; { document.getElementById("myout").innerHTML += x + "\n"; },
       }
     };
    fetch("out.wasm").then(response =&gt;
       response.arrayBuffer()
    ).then(bytes =&gt;
       WebAssembly.instantiate(bytes, imports)
    ).then(results =&gt; {
       window.main = results.instance.exports.main;
       window.main();
    });
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div></div>
<div class="paragraph"><p>Carefully observe that we have added a <code>_printi()</code> function to the
<code>imports</code> variable.  The original output at the end has been
removed.</p></div>
<div class="paragraph"><p>To make the <code>_printi</code> function available to Wasm, it has to be explicitly
imported.  This is done by making import records and making a few minor
modifications as shown in this extension to the encoder:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>class WasmEncoder:
    def __init__(self):
        ...
        # Imported functions
        self.imports = [ ]

    def import_function(self, module, name, parmtypes, rettypes):
        assert not self.exports, "All imported functions must be declared first"
        self.functions[name] = len(self.signatures)
        self.signatures.append(encode_signature(parmtypes, rettypes))
        self.imports.append(encode_name(module)+encode_name(name)+b'\x00' +
                            encode_unsigned(self.functions[name]))

    ...

    def encode_module(self):
        module = b'\x00asm\x01\x00\x00\x00'
        module += encode_section(1, encode_vector(self.signatures))

        # --- Next two lines added/modified. Don't forget slice on 2nd line!
        module += encode_section(2, encode_vector(self.imports))
        vec = [encode_unsigned(v) for v in self.functions.values()][len(self.imports):]
        # ---

        module += encode_section(3, encode_vector(vec))
        module += encode_section(6, encode_vector(self.global_defns))
        module += encode_section(7, encode_vector(self.exports))
        module += encode_section(10, encode_vector(self.funccode))
        return module

    ...

    # Call the imported '_printi' function
    def encode_PRINTI(self):
        self.wcode += b'\x10' + encode_unsigned(self.functions['_printi'])</code></pre>
</div></div>
<div class="paragraph"><p>To use this new encoder, you need to declare the imported runtime function
and fiddle a bit with type signatures.  Do this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>encoder = WasmEncoder()

# Declare the runtime function
encoder.import_function("runtime", "_printi", [i32], [])

# Encode main(). Note: Return type changed to [].
encoder.encode_function("main", [], [], [], code)

# Write out the module
with open('out.wasm', 'wb') as file:
    file.write(encoder.encode_module())</code></pre>
</div></div>
<div class="paragraph"><p>Try running your code to produce another <code>out.wasm</code> file and reload the hello page
in the browser.  You should see output being produced as before. If not, you&#8217;ll
have to do some debugging.  Whew!  That was some work.</p></div>
</div>
<div class="sect3">
<h4 id="_a_wasm_mini_reference">A Wasm Mini Reference</h4>
<div class="paragraph"><p>This section provides a short reference of useful Wasm instructions
and data encoding</p></div>
<div class="paragraph"><p>Types:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>b'\x7f'     =&gt; i32
b'\x7c'     =&gt; f64</code></pre>
</div></div>
<div class="paragraph"><p>It is usually easier to make aliases for the types:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>i32 = b'\x7f'
f64 = b'\x7c'</code></pre>
</div></div>
<div class="paragraph"><p>To define constants corresponding to the above types, do this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>b'\x41' &lt;value&gt;  =&gt; i32.const value
b'\x44' &lt;value&gt;  =&gt; f64.const value</code></pre>
</div></div>
<div class="paragraph"><p>The <code>&lt;value&gt;</code> needs to be encoded using <code>encoded_signed()</code> or <code>encode_f64()</code> depending
on the type.</p></div>
<div class="paragraph"><p>Here are some useful opcodes for math:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>b'\x6a'        =&gt; i32.add
b'\x6b'        =&gt; i32.sub
b'\x6c'        =&gt; i32.mul
b'\x6d'        =&gt; i32.div_s

b'\xa0'        =&gt; f64.add
b'\xa1'        =&gt; f64.sub
b'\xa2'        =&gt; f64.mul
b'\xa3'        =&gt; f64.div</code></pre>
</div></div>
<div class="paragraph"><p>To access a global variable, use these load and store instructions:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>b'\x23' &lt;globalidx&gt;  =&gt; global.get
b'\x24' &lt;globalidx&gt;  =&gt; global.set</code></pre>
</div></div>
<div class="paragraph"><p>To access a local variable, use load and store instructions:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>b'\x20' &lt;localidx&gt;  =&gt; local.get
b'\x21' &lt;localidx&gt;  =&gt; local.set</code></pre>
</div></div>
<div class="paragraph"><p>To call a function:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>b'\x10' &lt;funcidx&gt;  =&gt; call  (funcidx is function index)</code></pre>
</div></div>
<div class="paragraph"><p>More instructions can be found in the Wasm official specification.</p></div>
</div>
<div class="sect3">
<h4 id="_complete_encoder">Complete Encoder</h4>
<div class="paragraph"><p>Here is the source code for the complete encoder developed
in this part:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>code = [
   ('GLOBALI', 'x'),
   ('CONSTI', 4),
   ('STORE', 'x'),
   ('GLOBALI', 'y'),
   ('CONSTI', 5),
   ('STORE', 'y'),
   ('GLOBALI', 'd'),
   ('LOAD', 'x'),
   ('LOAD', 'x'),
   ('MULI',),
   ('LOAD', 'y'),
   ('LOAD', 'y'),
   ('MULI',),
   ('ADDI',),
   ('STORE', 'd'),
   ('LOAD', 'd'),
   ('PRINTI',)
]

def encode_unsigned(value):
    '''
    Produce an LEB128 encoded unsigned integer.
    '''
    parts = []
    while value:
        parts.append((value &amp; 0x7f) | 0x80)
        value &gt;&gt;= 7
    if not parts:
        parts.append(0)
    parts[-1] &amp;= 0x7f
    return bytes(parts)

def encode_signed(value):
    '''
    Produce a LEB128 encoded signed integer.
    '''
    parts = [ ]
    if value &lt; 0:
        # Sign extend the value up to a multiple of 7 bits
        value = (1 &lt;&lt; (value.bit_length() + (7 - value.bit_length() % 7))) + value
        negative = True
    else:
        negative = False
    while value:
        parts.append((value &amp; 0x7f) | 0x80)
        value &gt;&gt;= 7
    if not parts or (not negative and parts[-1] &amp; 0x40):
        parts.append(0)
    parts[-1] &amp;= 0x7f
    return bytes(parts)

assert encode_unsigned(624485) == bytes([0xe5, 0x8e, 0x26])
assert encode_unsigned(127) == bytes([0x7f])
assert encode_signed(-624485) == bytes([0x9b, 0xf1, 0x59])
assert encode_signed(127) == bytes([0xff, 0x00])

def encode_vector(items):
    '''
    A size-prefixed collection of objects.  If items is already
    bytes, it is prepended by a length and returned.  If items
    is a list of byte-strings, the length of the list is prepended
    to byte-string formed by concatenating all of the items.
    '''
    if isinstance(items, bytes):
        return encode_unsigned(len(items)) + items
    else:
        return encode_unsigned(len(items)) + b''.join(items)

import struct
def encode_f64(value):
    '''
    Encode a 64-bit float point as little endian
    '''
    return struct.pack('&lt;d', value)

def encode_name(name):
    '''
    Encode a text name as a UTF-8 vector
    '''
    return encode_vector(name.encode('utf-8'))

def encode_signature(argtypes, rettypes):
    return b'\x60' + encode_vector(argtypes) + encode_vector(rettypes)

def encode_section(sectnum, contents):
    return bytes([sectnum]) + encode_unsigned(len(contents)) + contents

i32 = b'\x7f'
f64 = b'\x7d'

class WasmEncoder:
    def __init__(self):
        # Global variables
        self.global_defns = [ ]

        # Global variable symbol table mapping names to declarations
        self.globals = { }

        # Function type signatures
        self.signatures = [ ]

        # Function name -&gt; signature map
        self.functions = { }

        # Function bodies
        self.funccode = [ ]

        # Exported functions
        self.exports = [ ]

        # Imported functions
        self.imports = [ ]

    def import_function(self, module, name, parmtypes, rettypes):
        assert not self.exports, "All imported functions must be declared first"
        self.functions[name] = len(self.signatures)
        self.signatures.append(encode_signature(parmtypes, rettypes))
        self.imports.append(encode_name(module)+encode_name(name)+b'\x00' + encode_unsigned(self.functions[name]))

    def encode_function(self, name, parmnames, parmtypes, rettypes, code):
        self.functions[name] = len(self.signatures)
        self.signatures.append(encode_signature(parmtypes, rettypes))
        self.exports.append(encode_name(name) + b'\x00' + encode_unsigned(self.functions[name]))

        # Create the local variable mapping
        self.locals = { pname: n for n, pname in enumerate(parmnames) }
        self.localtypes = [ ]

        # Emit instructions
        self.wcode = b''
        for op, *opargs in code:
            getattr(self, f'encode_{op}')(*opargs)

        # Put a block terminator on the code
        self.wcode += b'\x0b'

        # Save the function code body
        code = encode_vector(self.localtypes) + self.wcode
        self.funccode.append(encode_unsigned(len(code)) + code)

    def encode_module(self):
        module = b'\x00asm\x01\x00\x00\x00'
        module += encode_section(1, encode_vector(self.signatures))
        module += encode_section(2, encode_vector(self.imports))
        vec = [encode_unsigned(v) for v in self.functions.values()][len(self.imports):]
        module += encode_section(3, encode_vector(vec))
        module += encode_section(6, encode_vector(self.global_defns))
        module += encode_section(7, encode_vector(self.exports))
        module += encode_section(10, encode_vector(self.funccode))
        return module

    def encode_CONSTI(self, value):
        self.wcode += b'\x41' + encode_signed(value)

    def encode_ADDI(self):
        self.wcode += b'\x6a'

    def encode_MULI(self):
        self.wcode += b'\x6c'

    def encode_PRINTI(self):
        self.wcode += b'\x10' + encode_unsigned(self.functions['_printi'])

    def encode_GLOBALI(self, name):
        self.globals[name] = len(self.global_defns)
        self.global_defns.append(i32 + b'\x01\x41' + encode_signed(0) + b'\x0b')

    def encode_STORE(self, name):
        self.wcode += b'\x24' + encode_unsigned(self.globals[name])

    def encode_LOAD(self, name):
        self.wcode += b'\x23' + encode_unsigned(self.globals[name])


encoder = WasmEncoder()
encoder.import_function("runtime", "_printi", [i32], [])
encoder.encode_function("main", [], [], [], code)
with open('out.wasm', 'wb') as file:
    file.write(encoder.encode_module())</code></pre>
</div></div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-08-25 19:46:50 CDT
</div>
</div>
</body>
</html>
